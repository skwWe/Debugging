# Debugging
<p align = "center"><b>Это работа на отладку</b></p>
В данной работе были выполнены следующие задания: 
<p></p>
<h1>Создайте консольное приложение C# с следующим функционалом:</h1>
<br>
<h2>1.	Ввод данных: запрашивать у пользователя два числа (числа с плавающей точкой) и операцию (+, -, *, /).</h2>
</br>
<br>
<h2>2.	Вычисление: выполнять выбранную арифметическую операцию над введёнными числами.</h2>
</br>
<br>
</br>
<h2>3. Обработка ошибок:</h2> 
<li>Обрабатывать деление на ноль с помощью try-catch блока и выводить соответствующее сообщение об ошибке.</li>
<li>Обрабатывать ввод некорректных данных (например, буквы вместо чисел) с помощью try-parse и выводить сообщение об ошибке.</li>
<br>
</br>
<h2>4.	Вывод результата: выводить результат вычисления на консоль</h2>
<p></p>
<br></br>
<h1>Выполните следующие задание:</h1>
<p></p>
<h2>1. Внесите несколько преднамеренных ошибок:</h2>
  <p></p>
      <li>Добавьте ошибку деления на ноль (например, разделите на 0).</li>
      <li>Добавьте ошибку некорректного ввода (например, не обрабатывайте исключение FormatException).</li>
      <li>Добавьте ошибку в логике вычисления (например, неверный порядок операций).</li>
<h2>2. Используйте отладчик Visual Studio для поиска и исправления ошибок:</h2>
  <p></p>
<li>Точки останова (с условием, временную, трассировку, зависимую): установите точки останова в разных частях кода (перед вычислением, внутри try-catch блока, после вывода результата).</li>
<li>Immediate Window: проверьте значения переменных в окне Immediate Window в разных точках останова.  Попробуйте изменить значения переменных во время отладки.</li>
<li>Watch: добавьте переменные для наблюдения в окно Watch.</li>
<li>Stepping (Шаг за шагом): используйте Step Over, Step Into, Step Out для пошагового выполнения кода.</li>
<li>Исключения: проследите, как обрабатываются исключения (DivideByZeroException, FormatException).  Проверьте стек вызовов.</li>
  <p></p>
<h2>3. Используйте Debug и Trace (выводите в окно вывода и файл log):</h2>
  <p></p>
<li>Debug.WriteLine: Проверьте, что сообщения, выведенные с помощью Debug.WriteLine, появляются в окне Output во время отладки (в режиме Debug). Убедитесь, что эти сообщения не появляются в релизном режиме.</li>
<li>Trace.WriteLine: Настройте listener для Trace (например, используя TextWriterTraceListener), чтобы записывать информацию в файл. Проверьте, что сообщения, выведенные с помощью Trace.WriteLine, записываются в файл как в режиме Debug, так и в Release.</li>

<p></p>

<h2>4.	Напишите пользовательский метод для нагрузки системы (можно поискать готовые методы).</h2>
<p></p>
<h2>5.  Документируйте процесс отладки </h2>
<p></p>
Запишите, какие ошибки вы обнаружили, какие инструменты отладки вы использовали и как вы их использовали для исправления ошибок. Сделайте скриншоты ключевых моментов отладки (например, окна Immediate Window, стек вызовов, система отслеживания нагрузки системы). Обратите особое внимание на использование Debug.WriteLine и Trace.WriteLine и на разницу в их поведении
<br></br>
<p></p>
<h1>Напишите программу, которая генерирует длинную строку путем многократного конкатенирования подстрок.</h1>  
Программа должна выполнить следующие задачи:
<br></br>
<h2>1. Генерация строки методом 1 (конкатенация):</h2> 
Напишите функцию GenerateStringConcat(int count), которая генерирует строку путем конкатенирования count раз подстроки "Iteration: {i} ". Используйте оператор += для конкатенации.
<br></br>
<h2>2. Генерация строки методом 2 (StringBuilder):</h2> 
Напишите функцию GenerateStringSB(int count), которая выполняет ту же задачу, но с использованием StringBuilder.
<br></br>
<h2>3. Измерение производительности:</h2> 
Используйте Stopwatch для измерения времени выполнения каждой функции для различных значений count (например, 1000, 10000, 100000).  Запишите результаты в таблицу или файл.
<br></br>
<h2>4. Сравнение производительности:</h2> 
Cравните время выполнения обоих методов и сделайте вывод о преимуществах использования StringBuilder для конкатенации большого количества подстрок.
<br></br>
<h2>5. Дополнительное задание (сложная строка):</h2> 
Модифицируйте функции GenerateStringConcat и GenerateStringSB, чтобы они генерировали более сложную строку, включающую случайные числа и символы.  Повторите измерение производительности и сравните результаты. Например: «Iteration: {i}, RandomNumber: {randomNumber}, RandomChar: {randomChar} ".
<br></br>
<h2>6. Документируйте результаты: создайте отчет, содержащий:</h2>
<li>Код программы.</li>
<li>Таблицу с результатами замеров времени выполнения для обоих методов и разных значений count.</li>
<li>Графики (опционально), визуализирующие разницу в производительности.</li>
<li>Выводы о преимуществах StringBuilder на основе полученных данных.</li>

